generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Nft {
  id                  Int          @id
  nft_name            String
  nft_price           Float
  nft_image           String
  nft_collection_name String
  nft_collection_id   Int
  nft_description     String       @default("no description provided")
  nft_owner_address   String
  nft_creator_address String
  nft_mint_time       DateTime     @default(now())
  is_admin_minted     Boolean
  nft_liked           Int?
  up_for_sale         Boolean      @default(true)
  is_insured          Boolean
  events              Nft_events[]
  collection          Collection   @relation(fields: [nft_collection_id], references: [id])
  insurance           Insurance?
}

model Nft_events {
  id              Int      @id @default(autoincrement())
  // s_no      Int
  nft_event       String
  nft_price       Float
  from            String
  to              String
  time            DateTime
  nftId           Int
  asset_name      String
  nft             Nft      @relation(fields: [nftId], references: [id])
  // claim_requested Boolean  @default(false)
  loss_amount     Float? // this will keep track of the loss that has occured on sold event if the loss is >0 then you have lost money but if the loss is a negative value then the user has made money on the deal

  @@index([nftId])
}

model Collection {
  id           Int      @id
  name         String
  ownerAddress String
  price        Float
  image        String
  totalNfts    Int      @default(0)
  creationTime DateTime @default(now())

  nfts Nft[]
}

model User {
  id            Int     @id @default(autoincrement())
  walletAddress String  @unique
  name          String?
  email         String?
  number        String?
  address       String?
  bio           String?
  imgSrc        String?
}

model Insurance {
  id              Int                @id @default(autoincrement())
  coverage        Float
  startTime       DateTime           @default(now())
  expiration      DateTime
  active          Boolean
  approved        Boolean
  nftId           Int                @unique
  nft             Nft                @relation(fields: [nftId], references: [id])
  currentOwner    String
  status          InsuranceStatus     @default(ApprovalPending)
  // compensation    Compensation?
  is_extended     Boolean            @default(false)
  insuranceEvents Insurance_events[]
}

enum InsuranceStatus {
  ApprovalPending
  Approved
  Active
}


model Insurance_events {
  id          Int       @id @default(autoincrement())
  eventname   String
  insuranceid Int
  insurance   Insurance @relation(fields: [insuranceid], references: [id])
  date        DateTime  @default(now())
  assetType   String
}

model Compensation {  // this has some redundant  data
  id                 Int       @id @default(autoincrement())
  requestDate        DateTime  @default(now())
  loss               Float
  lossPercent        Float
  compensationAmount Float
  userAdress         String
  assetId            Int
  Status             String
  // soldValue          Float     @default(0)
  claimed            Boolean   @default(false)
  approval_date      DateTime?
  claimId            Int       @unique
  claim              Claims    @relation(fields: [claimId], references: [id])
}

model Admin {
  id       Int     @id @default(autoincrement())
  email    String  @unique
  password String
  isAdmin  Boolean @default(true)
}

model Otp {
  id        Int      @id @default(autoincrement())
  email     String
  hashedOtp String
  expiry    DateTime
  createdAt DateTime @default(now())

  @@index([email])
}

model Vectors {
  id        Int    @id @default(autoincrement())
  textChunk String
  embedding Json
}

model AdminWallet {
  id      Int        @id @default(autoincrement())
  address String
  name    String
  type    WalletType
}

enum WalletType {
  MINT
  COMPENSATION
  OWNER
}

model Claims {
  id                    Int           @id @default(autoincrement())
  userAddress           String
  compensationGenerated Boolean       @default(false)
  expiration            DateTime
  buyPrice              Float
  soldPrice             Float
  loss                  Float           // a negative value indicates that the user has made some profit on the deal instead
  assetId               Int
  coverage              Float
  lossPercent           Float
  date                  DateTime       @default(now())
  compensation          Compensation?
}